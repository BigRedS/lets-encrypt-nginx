#! /usr/bin/perl

use strict;
use Getopt::Long;
use Data::Dumper;

my $tlds_list = './tlds.txt';
my $get_tlds_script = './get-tld-list';
#my $domains_list = './domains.txt';
my $domains_list;
my $generate_tlds_list = undef;
my $dump_config = undef;


my $nginx = {};
$nginx->{ssl_socket} = '443';
$nginx->{cleartext_socket} = '80';
$nginx->{backend} = 'http://127.0.0.1';
$nginx->{log_path_prefix} = '/var/log/nginx/%SITE_NAME%';
$nginx->{config_dir} = '/etc/nginx/sites-available';
$nginx->{enable_site} = 'nginx_ensite';

my $certbot = {};
$certbot->{binary} = '/opt/letsencrypt/letsencrypt-auto',
$certbot->{config_dir} = '/etc/letsencrypt/configs/';
$certbot->{key_size} = 2048;
$certbot->{server} = 'https://acme-v01.api.letsencrypt.org/directory';
$certbot->{email} = 'letsencrypt@my-company.net';
$certbot->{webroot_path} = '/var/www/letsencrypt/';
$certbot->{certs_dir} = '/etc/ssl/certs/';


if(-f $ARGV[0]){
	($nginx,$certbot,$tlds_list,$get_tlds_script,$domains_list) = parse_config($ARGV[0]);
}


my $help;
GetOptions(
	'nginx-ssl-socket=s' => \$nginx->{ssl_socket},
	'nginx-cleartext-socket=s' => \$nginx->{cleartext_socket},
	'nginx-nocleartext' => \$nginx->{nocleartext},
	'nginx-backend=s' => \$nginx->{backend},
	'nginx-log-path-prefix=s' => \$nginx->{log_path_prefix},
	'nginx-config-dir=s' => \$nginx->{config_dir},
	'nginx-enable-site=s' => \$nginx->{enable_site},
	'nginx-include-file=s' => \$nginx->{include},

	'certbot-config-dir=s' => \$certbot->{config_dir},
	'certbot-key-size=s' => \$certbot->{key_size},
	'certbot-server-url=s' => \$certbot->{server},
	'certbot-email=s' => \$certbot->{email},
	'certbot-webroot=s' => \$certbot->{webroot_path},
	'certbot-binary=s' => \$certbot->{binary},
	'certbot-certs-dir' => \$certbot->{certs_dir},

	'tlds-list-file=s' => \$tlds_list,
	'get-tlds-script=s' => \$get_tlds_script,
	'domains=s' => \$domains_list,

	'clobber-nginx' => \$nginx->{clobber},
	'clobber-certbot' => \$certbot->{clobber},
	'skip-nginx' => \$nginx->{skip},
	'skip-certbot' => \$certbot->{skip},
	'dump-nginx' => \$nginx->{dump},
	'dump-certbot' => \$certbot->{dump},

	'generate-tlds-list' => \$generate_tlds_list,
	'dump-config' => \$dump_config,

	'help|h' => \$help,
) or die ("Failed to parse arguments");

$nginx->{cleartext_socket} = undef if $nginx->{nocleartext};
$certbot->{config_dir}.="/";
$certbot->{config_dir} =~ s#//#/#g;

$nginx->{config_dir}.="/";
$nginx->{config_dir} =~ s#//#/#g;

if($dump_config){
	dump_config($nginx, $certbot, $tlds_list, $get_tlds_script,$domains_list);
	exit;
}

if($help){
print <<"EOF";

lets-encrypt-nginx; script for configuring nginx and lets encrypt.

USAGE:

    lets-encrypt-nginx <options> --domains [path]

  or

    lets-encrypt-nginx --generate-tlds-file


Where [path] is to a file containing a list of domains, one per line.

OPTIONS:
(default/current values in brackets)

  --tlds-list-file [path]
      file containing a list of TLDs; see 'TLDS' below. 
      ($tlds_list)

  --get-tlds-script [path]
      path to script for generating tlds-list-file 
      ($get_tlds_script)

  --clobber-certbot
  --clobber-nginx
      Silently overwrite existing config for certbot and/or nginx respectively. 
      default is to print a warning and not overwrite.

  --skip-certbot
  --skip-nginx
      Skip certbot or Nginx configuration, respectively.

  --dump-certbot
  --dump-nginx
      Rather than create/enable config files, just print all generated config to
      stdout. Overriden by the 'skip' equivalents.
      dump-certbot is probably useless outside of debugging.


  nginx:

    --nginx-ssl-socket [port or ip-address:port]
        argument to nginx's 'listen' directive, for SSL connections. Do not
        include trailing 'ssl' at the end; *just* the socket ($nginx->{ssl_socket})

    --nginx-cleartext-socket [port or ip-address:port]
        same, for cleartext ($nginx->{cleartext_socket})

    --nginx-nocleartext 
        default is to add a 'listen 80' line to the nginx config. Set this to skip
        that

    --nginx-backend [url]
        URL to proxied-to backend ($nginx->{backend})

    --nginx-log-path-prefix [path]
        Used to create error and access log paths for the nginx config. The string
        '%SITENAME%' is replaced with the site name, and then '_error.log' or 
        '_access.log' is appended.
        ($nginx->{log_path_prefix})

    --nginx-config-dir [path]
        path to nginx sites-available directory ($nginx->{config_dir});

    --nginx-enable-site [command]
        thing to execute to enable the config that's presumably been written to 
        sites-avilable. Passed the file basename as its only argument; expects to
        have something like this installed: https://github.com/perusio/nginx_ensite
        Disable this by passing `/bin/true`
        ($nginx->{enable_site})

    --nginx-include-file [path]
        path to a file to include in the Nginx config. Is inserted verbatim, at the 
        end. It probably wants every line to be indented by one tab, for neatness' 
        sake
        ($nginx->{include})
        
  certbot:

    --certbot-config-dir [path]
        directory in which certbot config files are created 
       ($certbot->{config_dir})

    --certbot-key-size [bits]
        number of bits for the private key ($certbot->{key_size})
    
    --certbot-server-url [url]
        URL to the certbot server ($certbot->{server})
    
    --certbot-email [email-address]
        Email address for the Let's Encrypt cert ($certbot->{email})
    
    --certbot-webroot [path]
        Webroot directory ($certbot->{webroot_path})
    
    --certbot-binary [path]
        Path to certbot itself ($certbot->{binary})


TLDS

In order to determine a reasonable 'site name', this script needs to know which portion 
of a domain name is TLD or Second-level domain (SLD), and which portion is the part that
was actually registered by the customer.

It uses a file tlds.txt (specified with --tlds-list-file) as reference, which is a list,
one-item-per-line, of every IANA TLD, and every country-specific second-level domain 
(.co.uk, for example). Each domain is checked against this list, and the longest-matching
string is taken to deduce the registered domain. "mycompany.co.uk" would match both '.co.uk' 
and '.uk.'; .co.uk would be selected as the longest-match, and so 'mycompany' would be the 
name of the site, and 'mycompany.com' seen as related.

This file can be created with the included get-tld-list script:

    get-tld-list > ./tlds.txt

or by invoking this with --generate-tlds-file:

   lets-encrypt-nginx --generate-tlds-file

which will silently overwrite ./tlds.txt (or whatever's set with --tlds-list-file).

EOF
exit 0;
}


if(!$domains_list){
	print STDERR "Error: no domains list specified. Try with --help\n";
	exit 1;
}

$nginx->{certs_dir} = $certbot->{certs_dir};


# # #
# #
#

my %sites = get_sites($tlds_list,$domains_list);

foreach my $sitename (keys(%sites)){
	$nginx->{site_name} = $sitename;
	$nginx->{server_names} = join(" ", @{$sites{$sitename}});
	my @include_lines;
	if($nginx->{include} and ( -f $nginx->{include})){
		open(my $fh_include, "<", $nginx->{include}) or die ("Failed to to open nginx-include file '$nginx->{include}' : $!");
		@include_lines = <$fh_include>;
		close($fh_include);
	}
	$nginx->{include_lines} = \@include_lines;
	create_nginx_config($nginx) unless $nginx->{skip};

	$certbot->{site_name} = $sitename;
	$certbot->{names} = join(" ", @{$sites{$sitename}});
	create_certbot_config($certbot) unless $certbot->{skip};
}



sub create_certbot_config{
	my $params = shift;

	my $key_size = $params->{key_size};
	my $site_name = $params->{site_name};
	my $server = $params->{server};
	my $email = $params->{email};
	my $webroot_path = $params->{webroot_path};
	my $names = $params->{names};

	my $config_file = $params->{config_dir}.$site_name;
	warn("CertBot config '$config_file' already exists; skipping") and return 1 if -f $config_file and !$certbot->{clobber} and !$certbot->{dump};


my $letsencrypt = <<"EOF";
domains = $names
rsa-key-size = $key_size
server = $server
email = $email
text = True
authenticator = webroot
webroot-path = $webroot_path
EOF

	if($certbot->{dump}){
		print $letsencrypt;
		return 2;
	}
	open(my $fh, ">", $config_file) or warn ("Failed to open certbot config file '$config_file' for writing : $!") and return undef;
	print $fh $letsencrypt;
	close($fh);

	my $generate_cert_cmd = "$certbot->{binary} certonly --config ".$config_file;
	system($generate_cert_cmd);
	if($? != 0){
		print "Failed to generate cert for '$site_name' by running `$generate_cert_cmd`. Exited $?\n";
	}
	return 1;
}

sub create_nginx_config{
	my $params = shift;

	my $site_name = $params->{site_name};
	my $server_names = $params->{server_names};
	my $log_path_prefix = $params->{log_path_prefix};
	my $backend = $params->{backend};
	my $ssl_socket = $params->{ssl_socket};
	my $cleartext_socket = $params->{cleartext_socket};
	my $enable_site_cmd = $nginx->{enable_site};

	my $config_file = $params->{config_dir}.$params->{site_name};
	warn("Nginx config '$config_file' already exists; skipping") and return 1 if -f $config_file and !$nginx->{clobber} and !$nginx->{dump};

	$enable_site_cmd.=" $site_name";

	my $ssl_cert = $nginx->{certs_dir}.$site_name.'.chained.crt';
	my $ssl_key = $nginx->{certs_dir}.$site_name.'.key';

	$log_path_prefix =~ s/%SITE_NAME%/$site_name/;
	my $access_log = $log_path_prefix.'_access.log';
	my $error_log = $log_path_prefix.'_error.log';
	

	my $config = "Server {\n";
	$config.="\tlisten $ssl_socket ssl;\n";
	$config.="\tlisten $cleartext_socket;\n" if ($cleartext_socket);
	$config.=<<"EOF";
	server_name $server_names;
	location / {
		proxy_pass $backend;
	}

	ssl_certificate $ssl_cert;
	ssl_certificate_key $ssl_key;

	access_log ${log_path_prefix}_access.log
	error_log ${log_path_prefix}_error.log
EOF

	if($nginx->{include_lines}->[0]){
		$config.=join("", @{$nginx->{include_lines}});
	}

	$config.="}\n";

	if($nginx->{dump}){
		print $config;
		return 2;
	}
	open(my $fh, ">", $config_file) or warn ("Failed to open nginx config file '$config_file' for writing : $!") and return undef;
	print $fh $config;
	close($fh);
	system($enable_site_cmd);
	if($? != 0){
		print "Failed to enable '$site_name' by running `$enable_site_cmd`. Exited $?\n";
	}
	return;
}


sub get_sites{
	my $tlds_list = shift;
	my $domains_list = shift;
	my %tlds = get_tlds($tlds_list);
	my %sites;
	open(my $fh_domains, "<", $domains_list) or die ("Failed to open domains list file '$domains_list' : $!");
	while(my $line = readline($fh_domains)){
		chomp($line);
		next if $line =~ m/^\s*#/;
		next if $line =~~ m/^\s*$/;
		if($line =~ m/^(\S+)/){
			my $domain = $1;
			my ($sld) = $domain =~ m/(\.\w+\.\w+)$/;
			my ($tld) = $domain =~ m/(\.\w+)$/;
		
			my $site;
			# This is where a 'site' is defined, really; use
			#   ...$domain =~ m/([^\.]+$tld)$/...
			# to have it include the tld. 
			($site) = $domain =~ m/([^\.]+)$tld$/ if $tlds{$tld};
			($site) = $domain =~ m/([^\.]+)$sld$/ if $tlds{$sld};
	
			push(@{$sites{$site}}, $domain);
		}
	}
	return %sites;
}

sub get_tlds{
	my $tlds_list = shift;
	open(my $fh, '<', $tlds_list) or warn ("Failed to open tlds list file '$tlds_list' : $!");
	my @lines;
	while (my $line = readline($fh)){
		chomp($line);
		push(@lines, $line);
	}
	close($fh);
	my %tlds = map { $lines[$_] => $_ } 0..$#lines;
	return %tlds;
}

sub create_tlds_file{
	`$get_tlds_script > $tlds_list`;
	exit $?
}


sub parse_config {
	my $file = shift;
	my @keys = qw/nginx-ssl-socket nginx-cleartext-socket nginx-nocleartext nginx-backend nginx-log-path-prefix nginx-config-dir
	              clobber-nginx nginx-enable-site nginx-include-file
	              certbot-config-dir certbot-key-size certbot-server-url certbot-email certbot-webroot certbot-binary clobber-certbot
	              certbot-certs-dir
		      skip-nginx skip-certbot dump-nginx dump-certbot
	              tlds-list-file get-tlds-script domains 
	/;
	my ($nginx,$certbot,$tlds_list,$get_tlds_script,$domains_list);
	open (my $fh_config, "<", $file) or die ("Failed to open config file '$file' for reading : $!");
	while (my $line = readline($fh_config)){
		next if $line =~ m/^\s*#/;
		if($line =~ m/^(\S+)\s*=\s*(\S+)\s*$/){
			my($key,$value) = ($1,$2);
			if($key =~ m/^nginx-(\S+)/ or $key =~ m/(\S+)-nginx$/){
				$nginx->{$1} = $value;
			}elsif($key =~ m/^certbot-(\S+)/ or $key =~ m/(\S+)-certbot$/){
				$certbot->{$1} = $value;
			}elsif($key eq 'tlds-list-file'){
				$tlds_list = $value;
			}elsif($key eq 'get-tlds-script'){
				$get_tlds_script = $value;
			}elsif($key eq 'domains'){
				$domains_list = $value;
			}else{
				print STDERR ("Unrecognised config option '$key' (set to '$value'); ignoring");
			}
		}
	}
	return($nginx,$certbot,$tlds_list,$get_tlds_script,$domains_list);
}
sub dump_config{
	my ($nginx,$certbot,$tlds_list,$get_tlds_script,$domains_list) = @_;

	print "tlds-list-file=$tlds_list\n" if $tlds_list;
	print "get-tlds-script=$get_tlds_script\n" if $get_tlds_script;
	print "domains=$domains_list\n" if $domains_list;


	if($nginx){
		print hash_to_config('nginx', $nginx);
	}
	if($certbot){
		print hash_to_config('certbot', $certbot);
	}
}

sub hash_to_config{
	my $string;
	my $name = shift;
	my $hash = shift;
	foreach my $key (sort(keys(%{$hash}))){
		my $value = $hash->{$key};
		$key =~ s/\_/\-/g;
		$string.="$name-$key=$value\n";
	}
	$string.="\n";
	return $string;
}
