#! /usr/bin/perl

use strict;
use Getopt::Long;
use Data::Dumper;

my $debug = $ENV{'DEBUG'};

my $help = undef;
my $norun = undef;
my $nowrite = undef;
my $clobber = undef;
my $dump_sites = undef;
my $dump_config = undef;

my $config_file = './lengx.conf';

my $config = {};

$config->{certs_dir} = '/etc/ssl/certs/';
$config->{sites_list} = './sites.conf';

$config->{defaults}->{auto_www} = 1;
$config->{defaults}->{backend} = '127.0.0.1:80';

$config->{nginx_ssl_socket} = '443';
$config->{nginx_config_dir} = '/etc/nginx/sites-available';
$config->{nginx_enable_site} = 'nginx_ensite';
#$config->{nginx_nocleartext};
$config->{nginx_log_path_prefix} = '/var/log/nginx/%SITE_NAME%';
$config->{nginx_cleartext_socket} = '80';

$config->{certbot_email} = 'letsencrypt@my-company.net';
$config->{certbot_binary} = '/opt/letsencrypt/letsencrypt-auto',
$config->{certbot_key_size} = 2048;
$config->{certbot_server_url} = 'https://acme-v01.api.letsencrypt.org/directory';
$config->{certbot_config_dir} = '/etc/letsencrypt/configs/';
$config->{certbot_webroot_path} = '/var/www/letsencrypt/';

if(-f $ARGV[0]){
	$config_file = shift(@ARGV);
}

if($config_file eq '' or ! -f $config_file){
	print STDERR "Config file ($config_file) unset or not-existent\n";
	$help =1;
}else{
	print "Parsing config file '$config_file'\n" if $debug;
	$config = parse_config($config_file, $config);
}

GetOptions(
	'no-write-nginx' => \$config->{nginx_nowrite},
	'no-write-certbot' => \$config->{certbot_nowrite},
	'no-write' => \$nowrite,

	'no-run-nginx' => \$config->{nginx_norun},
	'no-run-certbot' => \$config->{certbot_norun},
	'no-run' => \$norun,

	'no-cleartext' => \$config->{nginx_nocleartext},

	'clobber-nginx' => \$config->{nginx_clobber},
	'clobber-certbot' => \$config->{certbot_clobber},
	'clobber-both' => \$clobber,

	'skip-nginx' => \$config->{nginx_skip},
	'skip-certbot' => \$config->{certbot_skip},

	'dump-nginx' => \$config->{nginx_dump},
	'dump-certbot' => \$config->{certbot_dump},

	'sites=s' => \$config->{sites_list},

	'dump-config' => \$config->{dump_config},
	'dump-sites' => \$dump_sites,

	'help|h' => \$help,
) or die ('Failed to parse arguments');

$config->{nginx_norun} = $config->{certbot_norun} = 1 if $norun;
$config->{nginx_nowrite} = $config->{certbot_nowrite} = 1 if $nowrite;
$config->{nginx_clobber} = $config->{certbot_clobber} = 1 if $clobber;

$config->{nginx_cleartext_socket} = undef if $config->{nginx_nocleartext};

$config->{certbot_config_dir}.='/';
$config->{certbot_config_dir} =~ s#//#/#g;

$config->{nginx_config_dir}.='/';
$config->{nginx_config_dir} =~ s#//#/#g;



if($help){
	usage();
}



if($config->{dump_config}){
	print dump_config($config);
	exit;
}

if(!$config->{sites_list}){
	print STDERR 'Error: no domains list specified. Try with --help\n';
	exit 1;
}


# # #
# #
#

if($debug){
	print STDERR "Debug on; dumping config\n";
	print STDERR dump_config($config);
}

my %sites = get_sites($config);
if($dump_sites){
	print dump_sites(\%sites);
	exit;
}


foreach my $sitename (keys(%sites)){

	my $site = $sites{$sitename};
	print STDERR "site: $sitename\n" if $debug;
	print "  server names: ".$site->{domains_list}."\n" if $debug;
	if($config->{nginx_skip}){
		print STDERR "  Skipping nginx \n" if $debug;
	}else{
		create_nginx_config($site, $config);
	}

	if($config->{certbot_skip}){
		print STDERR "  Skipping certbot\n" if $debug
	}else{
		create_certbot_config($site,$config);
	}
}



sub create_certbot_config{
	my ($site,$config) = @_;
	my $names = join(' ', @{$site->{domains_list}});
	my $site_name = $site->{sitename};
	

	my $config_file = $config->{certbot_config_dir}.$site_name;
	print STDERR "  certbot config file: '$config_file'" if $debug;
	warn("CertBot config '$config_file' already exists; skipping") and return 1 if -f $config_file and !$config->{certbot_clobber} and !$config->{certbot_dump};


	my $generate_cert_cmd = "$config->{certbot_binary} certonly --config ".$config_file;


my $letsencrypt = <<"EOF";
domains = $names
rsa-key-size = $config->{certbot_key_size}
server = $config->{certbot_server_url}
email = $config->{certbot_email}
text = True
authenticator = webroot
webroot-path = $config->{certbot_webroot_path}
EOF

	if($config->{certbot_dump}){
		print $letsencrypt."\n";
		return 2;
	}
	if($config->{certbot_nowrite}){
		print STDERR "    Not writing config ('nowrite' set)\n" if $debug;
	}else{
		open(my $fh, ">", $config_file) or warn ("Failed to open certbot config file '$config_file' for writing : $!") and return undef;
		print $fh $letsencrypt;
		close($fh);
	}

	print STDERR "    certbot command: $generate_cert_cmd\n" if $debug;
	if($config->{certbot_norun}){
		print STDERR "    not running; 'norun' set\n" if $debug;
	}else{
			system($generate_cert_cmd);
		if($? != 0){
			print "Failed to generate cert for '$site_name' by running `$generate_cert_cmd`. Exited $?\n";
		}
	}
	return 1;
}

sub create_nginx_config{
	my ($site,$config) = @_;

	my $site_name = $site->{sitename};
	my $server_names = join(" ", @{$site->{domains_list}});
	
	my $config_file = $config->{nginx_config_dir}.$site->{sitename};
	print STDERR "  Nginx config file: $config_file\n" if $debug;
	warn("Nginx config '$config_file' already exists; skipping") and return 1 if -f $config_file and !$config->{nginx_clobber} and !$config->{nginx_dump};


	if($config->{nginx_include_file}){
		my $nginx_include = $config->{nginx_include_file};
		$nginx_include =~ s/%SITE_NAME%/$site_name/;
		if( -f $nginx_include){
			my @include_lines;
			print STDERR  "  Including nginx include file '$nginx_include'\n" if $debug;
			open(my $fh_include, "<", $nginx_include) or print "Failed to to open nginx-include file '$nginx_include' : $!" ;
			@include_lines = <$fh_include>;
			close($fh_include);
			$config->{nginx_include_lines} = \@include_lines;
		}else{
			print STDERR "WARN: Passed '$nginx_include' as nginx-include file, but it doesn't exist. Ignoring\n";
		}
	}

	my $enable_site_cmd = $config->{nginx_enable_site}.' '.$site_name;

	my $ssl_cert = $config->{certs_dir}.$site_name.'.chained.crt';
	my $ssl_key = $config->{certs_dir}.$site_name.'.key';

	print STDERR "    ssl_cert: $ssl_cert\n" if $debug;
	print STDERR "    ssl_key: $ssl_key\n" if $debug;

	my $log_path = $config->{nginx_log_path_prefix};
	$log_path =~ s/%SITE_NAME%/$site_name/;
	my $access_log = $log_path.'_access.log';
	my $error_log = $log_path.'_error.log';


	print STDERR "    access_log: $access_log\n" if $debug;
	print STDERR "    error_log: $error_log\n" if $debug;

	my $nginx_config = "server {\n";
	$nginx_config.="\tlisten $config->{nginx_ssl_socket} ssl;\n";
	$nginx_config.="\tlisten $config->{nginx_cleartext_socket};\n" if ($config->{nginx_cleartext_socket} =~ m/.+/);
	$nginx_config.=<<"EOF";
	server_name $server_names;
	location / {
		proxy_pass $site->{backend};
	}

	ssl_certificate $ssl_cert;
	ssl_certificate_key $ssl_key;

	access_log $access_log;
	error_log $error_log;
EOF

	if($config->{nginx_include_lines}->[0]){
		$nginx_config.=join("", @{$config->{nginx_include_lines}});
	}

	$nginx_config.="}\n";

	if($config->{nginx_dump}){
		print $nginx_config;
		return 2;
	}
	if($config->{nginx_nowrite}){
		print STDERR "    Not writing config; 'nowrite' set\n" if $debug;
	}else{
		open(my $fh, ">", $config_file) or warn ("Failed to open nginx config file '$config_file' for writing : $!") and return undef;
		print $fh $nginx_config;
		close($fh);
	}

	print STDERR "    enable site command: $enable_site_cmd\n" if $debug;
	if($config->{nginx_norun}){
		print STDERR "    Not running enable_site command; 'norun' set\n" if $debug;
	}else{
		system($enable_site_cmd);
		if($? != 0){
			print "Failed to enable '$site_name' by running `$enable_site_cmd`. Exited $?\n";
		}
	}
	return;
}


sub get_sites{
	my $config = shift;

	my %sitss;
	open(my $fh_domains, "<", $config->{sites_list}) or print "Failed to open domains config file '$config->{sites_list}' : $!\n" and exit 255;
	my $sitename;
	while (my $line = readline($fh_domains)){
		chomp($line);
		next if $line =~ m/^\s*#/ or $line =~ m/^\s*$/;
		$line =~ s/\s+$//;

		if($line =~ m/^\w+/){
			if($sitename eq '_default'){
				$config->{defaults}->{auto_www} = $sites{_default}->{auto_www} if $sites{_default}->{auto_www} =~ m/.+/;
				$config->{defaults}->{backend} = $sites{_default}->{backend} if $sites{_default}->{backend} =~ m/.+/;
				delete($sites{_default});
			}

			my @domains = split(m/\s+/, $line);
			$sitename = $domains[0];
			$sites{$sitename}->{domains_list} = \@domains;
			$sites{$sitename}->{sitename} = $sitename;
			
			$sites{$sitename}->{auto_www} = $config->{defaults}->{auto_www};
			$sites{$sitename}->{backend} = $config->{defaults}->{backend};
		}
		if($line =~ m/^\s+(\S+)\s+(.+)$/){
			my ($key,$value) = ($1,$2);
			$sites{$sitename}->{backend} = $value if $key eq 'backend';
			if($key eq 'auto_www'){
				if($value =~ m/^(y|1)/i or $value =~ m/^on/i){
					$sites{$sitename}->{auto_www} = '1';
				}elsif($value =~ m/^n|0/i or $value =~ m/^off/i){
					$sites{$sitename}->{auto_www} = '0';
				}else{
					print STDERR "Failed attempt to set 'auto_www' to '$value'";
				}
			}
		}
	}
	return %sites;
}



sub parse_config {
	my $file = shift;
	my $config;
	my @keys = qw/nginx_ssl_socket nginx_cleartext_socket nginx_nocleartext nginx_log_path_prefix nginx_config_dir
	              nginx_clobber nginx_enable_site nginx_include_file nginx_skip
	              certbot_config_dir certbot_key_size certbot_server_url certbot_email certbot_webroot_path 
		      certbot_binary certbot_clobber certbot_skip
	              certs_dir sites_list
	/;
	open (my $fh_config, "<", $file) or die ("Failed to open config file '$file' for reading : $!");
	while (my $line = readline($fh_config)){
		next if $line =~ m/^\s*#/;
		if($line =~ m/^(\S+)\s*=\s*(\S+)\s*$/){
			my($key,$value) = ($1,$2);
			unless(grep{ /^$key$/ } @keys){
				print STDERR ("Unrecognised config option '$key' (set to '$value'); ignoring\n");
			}
			$config->{$key} = $value if $value =~ m/\S+/;
		}
	}
	return($config);
}

sub dump_config{
	my $config = shift;
	delete($config->{defaults});
	delete($config->{dump_config});
	my $string=hash_to_config($config);
	return $string;
}

sub dump_sites{
	my $sites = shift;
	my $string;
	foreach my $sitename(keys(%{$sites})){
		$string.="$sitename\n";
		foreach my $key (sort(keys(%{$sites{$sitename}}))){
			if($key eq 'domains_list'){
				$string.="  $key ".join(", ", @{$sites->{$sitename}->{$key}})."\n";
			}else{
				$string.="  $key $sites->{$sitename}->{$key}\n";
			}
		}
		$string.="\n";
	}
	return $string;
}

sub hash_to_config{
	my $string;
	my $hash = shift;
	foreach my $key (sort(keys(%{$hash}))){
		my $value = $hash->{$key};
		if(ref($value) eq 'ARRAY'){
			$value = join(", ", @{$value});
		}
		next unless $value =~ m/\S+/;
		$key =~ s/\_/\-/g;
		$string.="$key=$value\n";
	}
	$string.="\n";
	return $string;
}


sub usage{
print <<"EOF";

lets-encrypt-nginx; script for configuring nginx and lets encrypt.

USAGE:

  lets-encrypt-nginx [ <config-file> ] [--sites <sites-list>] [options]

  config-file defaults to $config_file; must be first argument when set
  sites-list defaults to $config->{sites_list}

See CONFIG and SITES below for a description of those two files. 

Options:

  --nocleartext

    Don't insert config to cause Nginx to listen for cleartext HTTP (on port
    80 by default). This makes nginx an SSL-terminator only.

  --no-write-nginx, --no-write-certbot, --no-write

    Don't write nginx config, certbot config, or either. Assembles the config, 
    but skips the bit where it would be writen.


  --no-run-nginx, --no-run-certbot, --no-run
  
    Don't run the nginx site-enabling command,  don't run the certbot cert-
    issuing command, or don't run either. 


  --clobber-nginx, --clobber-certbot, --clobber-both

    Overwrite existing nginx configs, certbot configs, or both. Default is to
    print a warning and skip the site.


  --skip-nginx --skip-certbot

    Skip all nginx configuring, or skip all certbot configuration. Calling with
    both is permitted, but pointless.


  --dump-nginx, --dump-certbot

    Dump nginx config to stdout, or dump certbot config to stdout (rather than
    writing to files). Not affected by --no-write*

  --dump-config, --dump-sites

    Dump the configuration, or site definitions, to stdout before doing any 
    processing. Config is dumped in the format of a valid config file, but sites
    are not.
    
CONFIG

The config file is a series of key=value pairs, and the keys exactly match those
used in the \%config hash internally. Check the top of the script for currently-
known ones, and use --dump-config to produce the file. 

Unsupported config keys cause a warning to be displayed, but don't prevent execution.
Lines beginning '#' are skipped as comments.

There should be an example at ./lengx.conf.example

SITES

Each site is defined, at minimum, by a single space-separated line of domain names. 
The first item in this list is taken as the name of the site. Options may be set on 
successive lines that begin with spaces; currently supported options are:

  auto_www - if set to 'on', automatically add the 'www' subdomain to all names. Set
             to 'off' to disable.
  backend  - literal string used as the argument to nginx's proxy_pass

The first site in the file may be named '_default' to set defaults for all successive 
sites. Lines beginning '#' are skipped as comments.

There should be an example at ./sites.conf.example

DEBUGGING

Set the environment variable 'DEBUG' to anything to have helpful(!) messages printed to stderr:

    DEBUG=1 lets-encrypt-nginx --no-run --no-write 

is a likely invocation here.

EOF
exit 0;
}
